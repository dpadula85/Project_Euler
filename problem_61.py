# -*- coding: utf-8 -*-
"""
Created on Mon Mar 23 11:17:33 2015

@author: Daniele
"""

#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
#all figurate (polygonal) numbers and are generated by the following formulae:
#
#Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
#Square	 	    P4,n=n2	 	    1, 4, 9, 16, 25, ...
#Pentagonal	 	P5,n=n(3nâˆ’1)/2    1, 5, 12, 22, 35, ...
#Hexagonal	 	P6,n=n(2nâˆ’1)	 	1, 6, 15, 28, 45, ...
#Heptagonal	 	P7,n=n(5nâˆ’3)/2	 1, 7, 18, 34, 55, ...
#Octagonal	 	P8,n=n(3nâˆ’2)	 	1, 8, 21, 40, 65, ...
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
#interesting properties.
#
#The set is cyclic, in that the last two digits of each number is the first two
#digits of the next number (including the last number with the first).
#Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
#pentagonal (P5,44=2882), is represented by a different number in the set.
#This is the only set of 4-digit numbers with this property.
#Find the sum of the only ordered set of six cyclic 4-digit numbers for which
#each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
#octagonal, is represented by a different number in the set.

#generate all four-digit polygonal numbers with their types

import time
from Euler import *

def next(types, data):
    if len(types) == 6 and str(data[0])[:2] == str(data[-1])[2:]:
        print data, sum(data)
    else:
        for t, d in families.get((types[-1], data[-1]), []):
            if t not in types:
                next(types + [t], data + [d])

start = time.time()

T = [(3, i) for i in filter(lambda x: x > 1000 and x < 10000, triangle_list(150))]
Q = [(4, i**2) for i in range(100) if i**2 > 1000]
P = [(5, i) for i in filter(lambda x: x > 1000 and x < 10000, penta_list(150))]
Hx = [(6, i) for i in filter(lambda x: x > 1000 and x < 10000, hexa_list(150))]
Hp = [(7, i) for i in filter(lambda x: x > 1000 and x < 10000, hepta_list(150))]
O = [(8, i) for i in filter(lambda x: x > 1000 and x < 10000, octa_list(150))]

Tot = T + Q + P + Hx + Hp + O

families = {}

for type1, data1 in Tot:
    for type2, data2 in Tot:
        if type1 != type2 and str(data1)[2:] == str(data2)[:2]:
            families[type1, data1] = families.get((type1, data1), []) + [(type2, data2)]

for type, data in families:
    next([type], [data])

elapsed = (time.time() - start)
print 'in %5.3f seconds' % elapsed